<!DOCTYPE html>
<html>

<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
</head>

<body>
  <div class="image-display">
    <h1>Indoor Designer</h1>
    <div>
      <button id="thick_wall" onclick="setMode(this)">Thick Wall</button>
      <button id="thin_wall" onclick="setMode(this)">Thin Wall</button>
      <button id="add_dot_button" onclick="addDot(this)">Add Dot</button>
    </div>
    <div>
      <canvas id="c_heatmap" width="700" height="700" style="border: 1px solid rgb(0,0,0);"></canvas>
    </div>
  </div>
  <h3>Params 1</h3>
  <p id="params-1"></p>
</body>

</html>

<style>
  .image-display {
    text-align: center;
    position: relative;
  }
</style>

<script type="text/javascript">
  var c = document.getElementById("c_heatmap");
  var ctx = c.getContext("2d");
  var walls = [];
  var wall_thickness = 3;
  var dots = [{ "id": 0, "x": 350, "y": 350 }];
  var r_d = 10;
  var next_dot_id = 1;
  var hovering_dot_id = false;
  const db_start = 20 * Math.log10(2.6) + 92.45;
  var p1s = {
    "current-x": "0",
    "current-y": "0",
    "mousesstate": "nothing yet",
    "dots": dots,
    "walls": walls,
  }

  function update_p1s() {
    var p1 = document.getElementById("params-1");
    p1.innerHTML = JSON.stringify(p1s);
  }

  function setMode(obj) {
    switch (obj.id) {
      case "thin_wall":
        wall_thickness = 3;
        break;
      case "thick_wall":
        wall_thickness = 10;
        break;
    }
    update_p1s();
  }

  function paint_dot(j_d, i_d, r_d) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(j_d, i_d, r_d, 0, Math.PI * 2);
    ctx.fill();
  }

  function dbmToColor(dbm) {
    var temp = -255 / 80 * (20 + dbm);
    if (temp < 0) {
      return 0;
    } else if (temp > 255) {
      return 255;
    } else {
      return temp;
    }
  }

  function ijk(x1, y1, x2, y2) {
    return [y2 - y1, x2 - x1, y1 * x2 - x1 * y2]
  }

  function paint_heatmap(step_size = 7) {
    // todo: make calculation on all dots, not just last one
    var h_steps_size = v_steps_size = step_size;
    var nr_horizontal_boxes = c.clientWidth / h_steps_size;
    var nr_vertical_boxes = c.clientHeight / v_steps_size;

    for (var i = 0; i < nr_vertical_boxes * v_steps_size; i++) {
      for (var j = 0; j < nr_horizontal_boxes * h_steps_size; j++) {
        var dbm = -10000;
        for (var dot in dots) {
          var d = dots[dot];
          var i_d = d["y"],
            j_d = d["x"];
          var il = i - i_d;
          var jl = j - j_d;
          var kl = i_d * j - i * j_d;
          var lx_min = Math.min(j, j_d);
          var lx_max = Math.max(j, j_d);
          var ly_min = Math.min(i, i_d);
          var ly_max = Math.max(i, i_d);
          // value if no walls are in between
          var dbm_this_dot = 17 - (20 * Math.log10(Math.sqrt(Math.pow(i - i_d, 2) + Math.pow(j - j_d, 2)) / 20000) + db_start);

          for (var wall in walls) {
            var w = walls[wall];
            var iw = w["y1"] - w["y0"];
            var jw = w["x1"] - w["x0"];
            var kw = w["y0"] * w["x1"] - w["y1"] * w["x0"];
            var wx_min = Math.min(w["x0"], w["x1"]);
            var wx_max = Math.max(w["x0"], w["x1"]);
            var wy_min = Math.min(w["y0"], w["y1"]);
            var wy_max = Math.max(w["y0"], w["y1"]);
            var x_I = (kw * jl - kl * jw) / (il * jw - iw * jl);
            var y_I = (kw * il - kl * iw) / (il * jw - iw * jl);
            if (0 < x_I && x_I < c.clientWidth && 0 < y_I && y_I < c.clientHeight && lx_min <= x_I && x_I <= lx_max && ly_min <= y_I && y_I <= ly_max && wx_min <= x_I && x_I <= wx_max && wy_min <= y_I && y_I <= wy_max) {
              var slope_l = il / jl;
              var slope_w = iw / jw;
              // todo: angle maybe wrong, see raymap function below
              var angle = Math.atan((slope_l - slope_w) / (1 + (slope_l * slope_w)));
              dbm_this_dot -= w["thickness"] / angle ** 2;
            }
          }

          if (dbm_this_dot > dbm) {
            dbm = dbm_this_dot;
          }
        }
        var color_rule = dbmToColor(dbm);
        ctx.fillStyle = "rgb(" + color_rule + "," + color_rule + ", " + color_rule + ")";
        ctx.fillRect(j, i, h_steps_size, v_steps_size);
        j += h_steps_size - 1;
      }
      i += v_steps_size - 1;
    }

    // draw walls
    for (var wall in walls) {
      var w = walls[wall];
      ctx.beginPath();
      ctx.moveTo(w["x0"], w["y0"]);
      ctx.lineTo(w["x1"], w["y1"]);
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = w["thickness"];
      ctx.lineJoin = ctx.lineCap = 'round';
      ctx.stroke();
    }
    // draw dots
    for (var dot in dots) {
      var d = dots[dot];
      paint_dot(d["x"], d["y"], r_d);
    }
    update_p1s();
  }


  function direction_points(x, y, angle) {
    // return an arbitrary point in the wright direction from starting point
    // x, y are coordinates of starting point
    var distance = 2000;
    return [x + Math.cos(angle) * distance, y + Math.sin(angle) * distance];
  }

  function initDirs(x, y, num) {
    var angles = [];
    for (var i = 1; i <= num; i++) {
      angles.push((2 * i * Math.PI / num));
    }
    var dirs = [];
    for (var a in angles) {
      dirs.push(direction_points(x, y, angles[a]));
    }
    return dirs;
  }

  function draw_helper_line(x0, y0, x1, y1, width = 0.5) {
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = width;
    ctx.stroke();
  }

  function paint_raymap(step_size = 7) {
    // todo: make calculation on all dots, not just last one
    var h_steps_size = v_steps_size = step_size;
    var nr_horizontal_boxes = c.clientWidth / h_steps_size;
    var nr_vertical_boxes = c.clientHeight / v_steps_size;
    var dbm = -10000;

    for (var dot in dots) {
      var d = dots[dot];
      var i_d = d["y"],
        j_d = d["x"];
      var initial_dirs = initDirs(j_d, i_d, 80);

      for (var dir in initial_dirs) {
        var j = initial_dirs[dir][0],
          i = initial_dirs[dir][1];
        // ctx.fillRect(j, i, h_steps_size, v_steps_size);
        var il = i - i_d;
        var jl = j - j_d;
        var kl = i_d * j - i * j_d;
        var lx_min = Math.min(j, j_d);
        var lx_max = Math.max(j, j_d);
        var ly_min = Math.min(i, i_d);
        var ly_max = Math.max(i, i_d);
        var x_I_current = y_I_current = 0;
        var current_angle = 0;
        var current_x_angle = 0;
        var dist_dummy = 100000;
        var dist_min = dist_dummy;
        var min_wall = 0;

        for (var wall in walls) {
          var w = walls[wall];
          var iw = w["y1"] - w["y0"];
          var jw = w["x1"] - w["x0"];
          var kw = w["y0"] * w["x1"] - w["y1"] * w["x0"];
          var wx_min = Math.min(w["x0"], w["x1"]);
          var wx_max = Math.max(w["x0"], w["x1"]);
          var wy_min = Math.min(w["y0"], w["y1"]);
          var wy_max = Math.max(w["y0"], w["y1"]);
          var x_I = (kw * jl - kl * jw) / (il * jw - iw * jl);
          var y_I = (kw * il - kl * iw) / (il * jw - iw * jl);
          var d_dir_I = Math.sqrt(Math.pow(x_I - j, 2) + Math.pow(y_I - i, 2));
          var d_dir_dot = Math.sqrt(Math.pow(j - j_d, 2) + Math.pow(i - i_d, 2));

          if (wx_min < x_I && x_I < wx_max && wy_min < y_I && y_I < wy_max && d_dir_I < d_dir_dot) {
            var current_dist = Math.sqrt(Math.pow(x_I - j_d, 2) + Math.pow(y_I - i_d, 2));
            if (current_dist < dist_min) {
              dist_min = current_dist;
              x_I_current = x_I;
              y_I_current = y_I;
              var slope_l = il / jl;
              var slope_w = iw / jw;
              var angle_between_line = Math.atan((slope_w - slope_l) / (1 + (slope_l * slope_w)));
              var angle_wall_coord_x_axes = Math.atan(slope_w);
              current_angle = angle_between_line;
              current_x_angle = angle_wall_coord_x_axes;

              // check if going to right side
              var inf_points = direction_points(x_I_current, y_I_current, current_x_angle + current_angle);
              var x_inf = inf_points[0];
              var y_inf = inf_points[1];
              var ii = y_inf - i_d;
              var ji = x_inf - j_d;
              var ki = i_d * x_inf - y_inf * j_d;
              var x_I2 = (kw * ji - ki * jw) / (ii * jw - iw * ji);
              var y_I2 = (kw * ii - ki * iw) / (ii * jw - iw * ji);
              var d_inf_dot = Math.sqrt(Math.pow(x_inf - j_d, 2) + Math.pow(y_inf - i_d, 2));
              var d_inf_wall = Math.sqrt(Math.pow(x_I2 - x_inf, 2) + Math.pow(y_I2 - y_inf, 2));
              if (d_inf_wall < d_inf_dot) {
                current_angle += Math.PI;
              }
            }
          }
        }

        if (dist_min < dist_dummy) {
          //paint dot line for now
          ctx.beginPath();
          ctx.moveTo(x_I_current, y_I_current);
          ctx.lineTo(j_d, i_d);
          ctx.strokeStyle = 'green';
          ctx.lineWidth = 5;
          ctx.stroke();
          // paint reflection line
          var inf_points = direction_points(x_I_current, y_I_current, current_x_angle + current_angle);
          var x_reflect_inf = inf_points[0];
          var y_reflect_inf = inf_points[1];
          draw_helper_line(x_I_current, y_I_current, x_reflect_inf, y_reflect_inf, width = 2);
        }
      }
    }

    // draw walls
    for (var wall in walls) {
      var w = walls[wall];
      ctx.beginPath();
      ctx.moveTo(w["x0"], w["y0"]);
      ctx.lineTo(w["x1"], w["y1"]);
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = w["thickness"];
      ctx.lineJoin = ctx.lineCap = 'round';
      ctx.stroke();
    }
    // draw dots
    for (var dot in dots) {
      var d = dots[dot];
      paint_dot(d["x"], d["y"], r_d);
    }
    update_p1s();
  }
  paint_raymap();

  function addDot(obj) {
    dots.push({ "id": next_dot_id, "x": 40, "y": 40 });
    next_dot_id += 1;
    paint_raymap(step_size = 3);
  }

  //Variables
  var canvasx = $(c).offset().left;
  var canvasy = $(c).offset().top;
  var last_mousex = last_mousey = 0;
  var mousex = mousey = 0;
  var mousedown = false;
  var dot_hover = false;
  var moving_dot = false;
  var last_wall_id = -1;
  var time = Date.now();

  //Mousedown
  $(c).on('mousedown', function (e) {
    last_mousex = parseInt(e.clientX - canvasx);
    last_mousey = parseInt(e.clientY - canvasy);
    dot_hover = hoveringDot(last_mousex, last_mousey);
    if (dot_hover) {
      // wait and see if dot is dragged
      moving_dot = true;
      time = Date.now();
    } else {
      mousedown = true;
      last_wall_id += 1;
      walls.push({ "id": last_wall_id, "x0": last_mousex, "y0": last_mousey, "thickness": wall_thickness });
    }
    p1s["mousesstate"] = "down";
    update_p1s();
  });

  //Mousemove
  $(c).on('mousemove', function (e) {
    mousex = parseInt(e.clientX - canvasx);
    mousey = parseInt(e.clientY - canvasy);
    var elapsed = Date.now() - time;
    if (moving_dot && elapsed > 10) {
      p1s["dots"][hovering_dot_id]["x"] = mousex;
      p1s["dots"][hovering_dot_id]["y"] = mousey;
      paint_heatmap(step_size = 10);
    }
    p1s["current-x"] = mousex;
    p1s["current-y"] = mousey;
    p1s["mousesstate"] = "move";
    update_p1s();
  });

  //Mouseup
  $(c).on('mouseup', function (e) {
    if (dot_hover) {
      //repaint dot
      p1s["dots"][hovering_dot_id]["x"] = mousex;
      p1s["dots"][hovering_dot_id]["y"] = mousey;
      moving_dot = false;
      dot_hover = false;
    } else {
      mousedown = false;
      walls[walls.length - 1]["x1"] = mousex;
      walls[walls.length - 1]["y1"] = mousey;
    }
    paint_raymap(step_size = 3);
    p1s["mousesstate"] = "up";
    update_p1s();
  });

  function hoveringDot(x, y) {
    for (var dot in dots) {
      var d = dots[dot];
      if (Math.sqrt(Math.pow(x - d["x"], 2) + Math.pow(y - d["y"], 2)) < 10) {
        hovering_dot_id = d["id"];
        return true;
      }
    }
    return false;
  }
</script>